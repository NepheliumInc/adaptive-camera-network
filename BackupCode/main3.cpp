

//Mysql Libraries
#include "mysql_connection.h"
#include "mysql_driver.h"
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>

//QT Libraries
#include <QtWidgets/QApplication>
#include <QFileInfo>
#include <QLabel>
#include <QCoreApplication>
#include <QDir>
#include <QDebug>
#include <QString>

//Standard Libraries
#include <fstream>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <iostream>

//Opencv Libraries
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/video/background_segm.hpp>

using namespace cv;
using namespace std;

//Function Calls


//Global Variables
int main()
{
	/* The behavior of mkdir is undefined for anything other than the "permission" bits */
	QString path = "C:\\Projects\\Output";
	QDir dir(path);
	if (!dir.exists())
	{
		qDebug() << "Creating " << path << "directory";
		dir.mkpath(path);
	}
	else
	{
		qDebug() << path << " already exists";
	}



	namedWindow("Shadow_Removed", WINDOW_AUTOSIZE);
	namedWindow("MOG2", WINDOW_AUTOSIZE);
	namedWindow("Blur_Resize", WINDOW_AUTOSIZE);
	namedWindow("Extracted Image", WINDOW_AUTOSIZE);
	namedWindow("Saved Image", WINDOW_AUTOSIZE);
	//namedWindow("Contour Drawing", WINDOW_AUTOSIZE);

	//global variables/Users/dehan/Documents/xc/xcode/opncvStarter/OpencvTut/OpencvTut/ProBlobDetection.cpp
	Mat frame; //current frame
	Mat resize_blur_Img;
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	Mat binaryImg;
	//Mat TestImg;
	Mat ContourImg; //fg mask fg mask generated by MOG2 method
	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	char fileName[100] = "C:\\Projects\\PRG6.avi"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
	const char* homeDir = getenv("HOME");

	QString path_correct = "C:\\Projects\\Output\\file1\\correct";
	QString path_non = "C:\\Projects\\Output\\file1\\non";

	QDir dir_correct(path_correct);
	QDir dir_non(path_non);


	if (!dir_correct.exists())
	{
		qDebug() << "Creating " << path_correct << "directory";
		dir_correct.mkpath(path_correct);

	}
	else
	{
		qDebug() << path_correct << " already exists";
		//removing all files in folder
		dir.setNameFilters(QStringList() << "*.*");
		dir.setFilter(QDir::Files);
		foreach(QString dirFile, dir_correct.entryList())
		{
			dir_correct.remove(dirFile);
		}
	}

	if (!dir_non.exists())
	{
		qDebug() << "Creating " << path_non << "directory";
		dir_non.mkpath(path_non);
	}
	else
	{
		qDebug() << path_non << " already exists";
		dir.setNameFilters(QStringList() << "*.*");
		dir.setFilter(QDir::Files);
		foreach(QString dirFile, dir_non.entryList())
		{
			dir_non.remove(dirFile);
		}
	}

		//char fileName[100] = "/Users/dehan/projects/loot.3gp";
		VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera

	//morphology element
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	bool flag = true;
	//unconditional loop


	float loopCounter = 1;
	float averageTime = 0;
	while (true) {
		clock_t t = clock();
		Mat cameraFrame;
		Mat resizeFrame;
		Mat greyFrame;
		if (!(stream1.read(frame))) //get one frame form video
			break;

		//cvtColor(frame, frame, CV_BGR2HSV);
		resize_blur_Img = frame;


		//Resize
		resize(frame, resize_blur_Img, Size(frame.size().width, frame.size().height));
		resize(frame, resizeFrame, Size(frame.size().width, frame.size().height));
		imshow("Original", resizeFrame);

		cvtColor(resize_blur_Img, greyFrame, CV_BGR2GRAY);
		//Blur
		blur(resize_blur_Img, resize_blur_Img, Size(4, 4));
		//Background subtraction
		pMOG2->operator()(resize_blur_Img, fgMaskMOG2, -1);//,-0.5);

		///////////////////////////////////////////////////////////////////
		//pre procesing
		//1 point delete
		//morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
		morphologyEx(fgMaskMOG2, binaryImg, CV_MOP_CLOSE, element);
		//morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);
		//imshow("BinImage Before Thresh", binaryImg);

		//Shadow delete
		//Binary
		threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);
		//imshow("BinImage", binaryImg);

		//Find contour
		ContourImg = binaryImg.clone();
		//less blob delete
		vector< vector< Point> > contours;
		findContours(ContourImg,
			contours, // a vector of contours
			CV_RETR_EXTERNAL, // retrieve the external contours
			CV_CHAIN_APPROX_NONE); // all pixels of each contours

		vector< Rect > output;
		vector< vector< Point> >::iterator itc = contours.begin();


		///CONVEX HULL TESTING
		Mat threshold_output;
		vector<Vec4i> hierarchy;

		/// Find the convex hull object for each contour
		vector<vector<Point> >hull(contours.size());
		for (int i = 0; i < contours.size(); i++)
		{
			convexHull(Mat(contours[i]), hull[i], false);
		}

		/// Draw contours + hull results
		Mat drawing = Mat::zeros(binaryImg.size(), CV_8UC3);
		Mat mask = Mat::zeros(resizeFrame.size(), CV_8UC3);
		floodFill(drawing, Point(), Scalar(255, 255, 255));

		for (int i = 0; i< contours.size(); i++)
		{
			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			//drawContours( drawing, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
			drawContours(drawing, hull, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			//floodFill(drawing,Point(),Scalar(100,100,100));

		}
		floodFill(drawing, Point(), Scalar(0, 0, 0));
		resizeFrame.copyTo(mask, drawing); // 'image' is the image you used to compute the contours.

		imshow("hulls", drawing);
		imshow("mask", mask);

		cvWaitKey(1);
		////////

		for (int i = 0; i < contours.size(); i++)
		{
			// Get bounding box for contour
			Rect roi = boundingRect(contours[i]);

			Mat mask2 = Mat::zeros(greyFrame.size(), CV_8UC1);
			drawContours(mask2, contours, i, Scalar(255), CV_FILLED);
			Mat contourRegion;
			Mat contourRegion2;

			Mat imageROI;


			//Copy the relevant pixels
			resizeFrame.copyTo(imageROI, mask); // 'image' is the image you used to compute the contours.

			//imshow("Contour Drawing 1", imageROI);


			//Crop the region of interest
			contourRegion = imageROI(roi);





			time_t seconds;
			time(&seconds);
			stringstream ss;
			ss << seconds;
			string ts = ss.str();
			double heightToWidthRatio = static_cast<double>(roi.height) / static_cast<double>(roi.width);
			if (roi.width > 30 && roi.width < 100 && roi.height>30)
			{
				if (heightToWidthRatio > 1.3)
				{

					imwrite("C:\\Projects\\Output\\file1\\correct\\" + ts + to_string(i) + ".jpg", contourRegion);


					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);
					waitKey(100);
				}
				else{
					imwrite("C:\\Projects\\Output\\file1\\non\\" + ts + to_string(i) + ".jpg", contourRegion);


					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);
					waitKey(1);
				}
			}

		}
	}

}


///Draws a histogram and return
Mat drawHistogram(Mat greyImage)
{////
	float colourFrequency2[256] = {}; // u should give ={} bcos it will hav garbage values frm that array.
	for (int i = 0; i < greyImage.rows; i++){
		for (int j = 0; j < greyImage.cols; j++){
			int pixel = greyImage.at<uchar>(i, j);
			colourFrequency2[pixel] += 1;
		}
	}

	float max = 0.0;
	for (int i = 0; i < 256; i++){
		if (max < colourFrequency2[i]){
			max = colourFrequency2[i];
		}
	}
	Mat histogram2(310, 260, CV_8UC3, Scalar(255, 255, 255));

	int hist2[256] = {};
	float maxd = max;
	for (int i = 0; i < 256; i++){
		hist2[i] = cvRound(double(colourFrequency2[i] / maxd) * 300.0);
		Point pt1 = Point(i, 300 - hist2[i]);
		Point pt2 = Point(i, 300);
		line(histogram2, pt1, pt2, Scalar(0, 0, 0), 1, 8, 0);
	}

	return histogram2;

}