//
//  ProBlobDetection.cpp
//  OpencvTut
//
//  Created by Dehan on 4/20/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//
#include <iostream>

#include "mysql_connection.h"
#include "mysql_driver.h"
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>
#include <QtWidgets/QApplication>
#include <QFileInfo>
#include <QLabel>
#include <fstream>
#include <sys/stat.h>
#include <QCoreApplication>
#include <QDir>
#include <QDebug>
#include <QString>
#include <stdlib.h>


#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include <opencv2/video/background_segm.hpp>
#include <stdio.h>
#include <time.h>
using namespace cv;
using namespace std;
void getDiffInVideo();
void drawHist();
Mat drawHist(Mat greyImage);
Mat src;
Mat dst;
Mat resizedFrame;
Mat processedFrame;
Mat edgeDetected;

Mat savedImage;
Mat savedHist;
RNG rng(12345);

///Removes any dir if exists
void make_directory(QString path);

void make_directory(QString path){

	QDir directory(path);
	if (!directory.exists())
	{
		qDebug() << "Creating " << directory << "directory";
		directory.mkpath(path);
	}
	else
	{
		qDebug() << path << " already exists";
		directory.setNameFilters(QStringList() << "*.*");
		directory.setFilter(QDir::Files);
		foreach(QString dirFile, directory.entryList())
		{
			directory.remove(dirFile);
		}
	}
}

//global variables
Mat frame; //current frame

int frameCounter = 0;
int main2()
{
	/* The behavior of mkdir is undefined for anything other than the "permission" bits */
	QString path = "C:\\Projects\\Output";
	QString path_correct = "C:\\Projects\\Output\\file1\\correct";
	QString path_non = "C:\\Projects\\Output\\file1\\non";
	make_directory(path_correct);
	make_directory(path_non);
	make_directory(path);




	//namedWindow("Shadow_Removed", WINDOW_AUTOSIZE);
	//namedWindow("MOG2", WINDOW_AUTOSIZE);
	//namedWindow("Blur_Resize", WINDOW_AUTOSIZE);
	//namedWindow("Extracted Image", WINDOW_AUTOSIZE);
	//namedWindow("Saved Image", WINDOW_AUTOSIZE);
	//namedWindow("Contour Drawing", WINDOW_AUTOSIZE);

	//global variables/Users/dehan/Documents/xc/xcode/opncvStarter/OpencvTut/OpencvTut/ProBlobDetection.cpp
	Mat frame; //current frame
	Mat resize_blur_Img;
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	Mat binaryImg;
	//Mat TestImg;
	Mat ContourImg; //fg mask fg mask generated by MOG2 method
	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	string fileName = "C:\\Projects\\PRG6.avi"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
	const char* homeDir = getenv("HOME");





	//char fileName[100] = "/Users/dehan/projects/loot.3gp";
	VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera

	//morphology element
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	bool flag = true;
	//unconditional loop

	
	float loopCounter = 1;
	float averageTime = 0;
	int skippedFrames = 0;
	//Used when numbering files
	int count = 0;
	for (int i = 0; i < skippedFrames; i++)
	{
		stream1.grab();

	}
	while (true) {
		clock_t t = clock();
		Mat cameraFrame;
		Mat resizeFrame;
		Mat greyFrame;
		if (!(stream1.read(frame))) //get one frame form video
			break;

		//cvtColor(frame, frame, CV_BGR2HSV);
		resize_blur_Img = frame;


		//Resize
		resize(frame, resize_blur_Img, Size(frame.size().width , frame.size().height ));
		resize(frame, resizeFrame, Size(frame.size().width, frame.size().height));
		////*imshow("Original", resizeFrame);

		cvtColor(resize_blur_Img, greyFrame, CV_BGR2GRAY);
		//Blur
		blur(resize_blur_Img, resize_blur_Img, Size(4, 4));
		//Background subtraction
		pMOG2->operator()(resize_blur_Img, fgMaskMOG2, -1);//,-0.5);

		morphologyEx(fgMaskMOG2, binaryImg, CV_MOP_CLOSE, element);

		//Shadow delete
		//Binary
		threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);

		//Find contour
		ContourImg = binaryImg.clone();
		//less blob delete
		vector< vector< Point> > contours;
		findContours(ContourImg,
			contours, // a vector of contours
			CV_RETR_EXTERNAL, // retrieve the external contours
			CV_CHAIN_APPROX_NONE); // all pixels of each contours

		vector< Rect > output;
		vector< vector< Point> >::iterator itc = contours.begin();


		///CONVEX HULL TESTING
		Mat threshold_output;
		vector<Vec4i> hierarchy;

		/// Find the convex hull object for each contour
		vector<vector<Point> >hull(contours.size());
		for (int i = 0; i < contours.size(); i++)
		{
			convexHull(Mat(contours[i]), hull[i], false);
		}

		//Find bounding rectangle
		vector<Rect> boundRect(contours.size());
		for (int i = 0; i < contours.size(); i++)
		{
			approxPolyDP(Mat(contours[i]), contours[i], 3, true);
			boundRect[i] = boundingRect(Mat(contours[i]));
		}


		/// Draw contours + hull results
		Mat drawing = Mat::zeros(binaryImg.size(), CV_8UC3);
		Mat drawing2 = Mat::zeros(binaryImg.size(), CV_8UC3);

		Mat mask = Mat::zeros(resizeFrame.size(), CV_8UC3);
		Mat mask2 = Mat::zeros(resizeFrame.size(), CV_8UC3);

		floodFill(drawing, Point(), Scalar(255, 255, 255));
		floodFill(drawing2, Point(), Scalar(255, 255, 255));

		for (int i = 0; i< contours.size(); i++)
		{
			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			//drawContours( drawing2, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
			drawContours(drawing, hull, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			rectangle(drawing2, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0);
			//floodFill(drawing,Point(),Scalar(100,100,100));

		}
		floodFill(drawing, Point(), Scalar(0, 0, 0));
		floodFill(drawing2, Point(), Scalar(0, 0, 0));
		resizeFrame.copyTo(mask, drawing); // 'image' is the image you used to compute the contours.
		resizeFrame.copyTo(mask2, drawing2); // 'image' is the image you used to compute the contours.

		////*imshow("hulls", drawing);
		////*imshow("mask", mask);

		////*imshow("hulls2", drawing2);
		////*imshow("mask2", mask2);
		////**cvWaitKey(1);
		////////

		for (int i = 0; i < contours.size(); i++)
		{
			// Get bounding box for contour
			Rect roi = boundingRect(contours[i]);
			Mat contourRegionConvex;
			Mat contourRegionBox;
			Mat contourRegionConvexMask;
			Mat imageROI;
			//Copy the relevant pixels
			resizeFrame.copyTo(imageROI, mask); // 'image' is the image you used to compute the contours.

			//Crop the region of interest
			contourRegionConvex = imageROI(roi);
			contourRegionConvexMask = drawing(roi);
			contourRegionBox = resizeFrame(roi);

			

			time_t seconds;
			time(&seconds);
			stringstream ss;
			ss << seconds;
			string ts = ss.str();
			double heightToWidthRatio = static_cast<double>(roi.height) / static_cast<double>(roi.width);
			if (roi.width > 30 && roi.width < 100 && roi.height>30)
			{
				if (heightToWidthRatio > 1.3)
				{
					string number = "";

					if (count < 10){
						number = "000"+  to_string(count);

					}
					else if (count < 100){
						number = "00" + to_string(count);
					}
					else if (count < 1000){
						number = "0" + to_string(count);
					}
					else{
						number = to_string(count);
					}
					string pathConvex = "C:\\Projects\\Output\\file1\\correct\\img_convex_" + number + ".jpg";
					string pathConvexMask = "C:\\Projects\\Output\\file1\\correct\\img_cmask_" + number + ".jpg";
					string pathBox = "C:\\Projects\\Output\\file1\\correct\\img_box_" + number + ".jpg";
					string pathFrame = "C:\\Projects\\Output\\file1\\correct\\img_frame_" + number + ".jpg";

					count++;
					imwrite(pathConvex, contourRegionConvex);
					imwrite(pathConvexMask, contourRegionConvexMask);
					imwrite(pathBox, contourRegionBox);
					imwrite(pathFrame, resizeFrame);

					////#*cvNamedWindow("contourRegionConvex", CV_WINDOW_NORMAL);
					////#*cvNamedWindow("contourRegionBox", CV_WINDOW_NORMAL);
					////#*("contourRegionConvexMask", CV_WINDOW_NORMAL);

					////*imshow("contourRegionConvex", contourRegionConvex);
					////*imshow("contourRegionBox", contourRegionBox);
					////*imshow("contourRegionConvexMask", contourRegionConvexMask);

					//cvResizeWindow("contourRegionBox", contourRegionBox.cols, contourRegionBox.rows); 
					/*cvResizeWindow("contourRegionConvex", contourRegionConvex.rows, contourRegionConvex.cols);
					cvResizeWindow("contourRegionBox", contourRegionBox.cols, contourRegionBox.rows);*/

					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);
					
				}
				else{
					imwrite("C:\\Projects\\Output\\file1\\non\\" + ts + to_string(i) + ".jpg", contourRegionConvex);


					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);
		
				}
			}

		}
	}
	return 0;
}

Mat drawHist(Mat greyImage)
{////
	float colourFrequency2[256] = {}; // u should give ={} bcos it will hav garbage values frm that array.
	for (int i = 0; i < greyImage.rows; i++){
		for (int j = 0; j < greyImage.cols; j++){
			int pixel = greyImage.at<uchar>(i, j);
			colourFrequency2[pixel] += 1;
		}
	}

	float max = 0.0;
	for (int i = 0; i < 256; i++){
		if (max < colourFrequency2[i]){
			max = colourFrequency2[i];
		}
	}
	Mat histogram2(310, 260, CV_8UC3, Scalar(255, 255, 255));

	int hist2[256] = {};
	float maxd = max;
	for (int i = 0; i < 256; i++){
		hist2[i] = cvRound(double(colourFrequency2[i] / maxd) * 300.0);
		Point pt1 = Point(i, 300 - hist2[i]);
		Point pt2 = Point(i, 300);
		line(histogram2, pt1, pt2, Scalar(0, 0, 0), 1, 8, 0);
	}

	return histogram2;

}