//
//  ProBlobDetection.cpp
//  OpencvTut
//
//  Created by Dehan on 4/20/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//
#include <iostream>

#include "mysql_connection.h"
#include "mysql_driver.h"
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>
#include <QtWidgets/QApplication>

#include <QtCore\QFileInfo>
#include <QtWidgets\qlabel.h>
#include <fstream>
#include <sys/stat.h>
#include <QtCore\QCoreApplication>
#include <QtCore\qdir.h>
#include <QtCore\QDebug>
#include <QtCore\QString>
#include <stdlib.h>


#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include <opencv2/video/background_segm.hpp>

#include "BlobDetection.h"

#include <stdio.h>
#include <time.h>
using namespace cv;
using namespace std;
void getDiffInVideo();
void drawHist();
Mat drawHist(Mat greyImage);
Mat src;
Mat dst;
Mat resizedFrame;
Mat processedFrame;
Mat edgeDetected;

Mat savedImage;
Mat savedHist;
RNG rng(12345);

///Removes any dir if exists
void make_directory(QString path);

void make_directory(QString path){

	QDir directory(path);
	if (!directory.exists())
	{
		qDebug() << "Creating " << directory << "directory";
		directory.mkpath(path);
	}
	else
	{
		qDebug() << path << " already exists";
		directory.setNameFilters(QStringList() << "*.*");
		directory.setFilter(QDir::Files);
		foreach(QString dirFile, directory.entryList())
		{
			directory.remove(dirFile);
		}
	}
}

//global variables
Mat frame; //current frame

int frameCounter = 0;
int main()
{
	BlobDetection blb;
	
	//blb.
	/* The behavior of mkdir is undefined for anything other than the "permission" bits */
	QString path = "C:\\Projects\\Output";
	QString path_correct = "C:\\Projects\\Output\\file1\\correctX";
	QString path_non = "C:\\Projects\\Output\\file1\\nonX";
	//make_directory(path_correct);
	//make_directory(path_non);
	//make_directory(path);

	Mat frame; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	//Mat TestImg;
	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);
	
	Ptr< BackgroundSubtractor> pMOG2Pointer; //MOG2 Background subtractor
	pMOG2Pointer = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	string fileName = "C:\\Projects\\PRG6.avi";
	VideoCapture stream1(fileName);  

	//morphology element
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	bool flag = true;


	
	float loopCounter = 1;
	float averageTime = 0;
	int skippedFrames = 0;
	int count = 0;
	for (int i = 0; i < skippedFrames; i++)
	{
		stream1.grab();

	}
	while (true) {


		clock_t t = clock();
		if (!(stream1.read(frame))) 
			break;

		vector< vector< Point> > contours;
		BlobDetection blbDetect;
		resize(frame, frame, Size(frame.size().width, frame.size().height));
		Mat originalFrame = frame.clone();

		contours = blbDetect.detectContours(frame,pMOG2Pointer, fgMaskMOG2);
		vector< vector< Point> >::iterator itc = contours.begin();


		///CONVEX HULL TESTING
		Mat threshold_output;
		vector<Vec4i> hierarchy;

		/// Find the convex hull object for each contour
		vector<vector<Point> >hull(contours.size());
		for (int i = 0; i < contours.size(); i++)
		{
			convexHull(Mat(contours[i]), hull[i], false);
		}

		////Find bounding rectangle
		//vector<Rect> boundRect(contours.size());
		//for (int i = 0; i < contours.size(); i++)
		//{
		//	approxPolyDP(Mat(contours[i]), contours[i], 3, true);
		//	boundRect[i] = boundingRect(Mat(contours[i]));
		//}


		/// Draw contours + hull results
		Mat hullDrawing = Mat::zeros(frame.size(), CV_8UC3);
		//Mat drawing2 = Mat::zeros(frame.size(), CV_8UC3);

		Mat mask = Mat::zeros(frame.size(), CV_8UC3);
		//Mat mask2 = Mat::zeros(frame.size(), CV_8UC3);

		floodFill(hullDrawing, Point(), Scalar(255, 255, 255));
		//floodFill(drawing2, Point(), Scalar(255, 255, 255));

		//Draw Convex HUll
		for (int i = 0; i< contours.size(); i++)
		{
			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			//drawContours( drawing2, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
			drawContours(hullDrawing, hull, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			//rectangle(drawing2, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0);

		}
		floodFill(hullDrawing, Point(), Scalar(0, 0, 0));
		//floodFill(drawing2, Point(), Scalar(0, 0, 0));
		originalFrame.copyTo(mask, hullDrawing); 
		//originalFrame.copyTo(mask2, drawing2); 

		//imshow("hulls", drawing);
		//imshow("mask", mask);

		//imshow("hulls2", drawing2);
		//imshow("mask2", mask2);
		cvWaitKey(1);
		////////

		for (int i = 0; i < contours.size(); i++)
		{
			// Get bounding box for contour
			Rect 
				
				
			roi = boundingRect(contours[i]);
			Mat imageHullCrop;
			//Copy the relevant pixels
			//representation of the hull drawing 
			originalFrame.copyTo(imageHullCrop, mask); // 'image' is the image you used to compute the contours.

			//Crop the region of interest
			Mat convexBlob = imageHullCrop(roi);
			Mat convexBlobMask = hullDrawing(roi);
			Mat rectBlob = originalFrame(roi);

			

			time_t seconds;
			time(&seconds);
			stringstream ss;
			ss << seconds;
			string ts = ss.str();
			double heightToWidthRatio = static_cast<double>(roi.height) / static_cast<double>(roi.width);
			if (roi.width > 30 && roi.width < 100 && roi.height>30)
			{
				if (heightToWidthRatio > 1.3)
				{
					string number = "";

					if (count < 10){
						number = "000"+  to_string(count);

					}
					else if (count < 100){
						number = "00" + to_string(count);
					}
					else if (count < 1000){
						number = "0" + to_string(count);
					}
					else{
						number = to_string(count);
					}
					string pathConvex = "C:\\Projects\\Output\\file1\\correctX\\img_convex_" + number + ".jpg";
					string pathConvexMask = "C:\\Projects\\Output\\file1\\correctX\\img_cmask_" + number + ".jpg";
					string pathBox = "C:\\Projects\\Output\\file1\\correctX\\img_box_" + number + ".jpg";
					string pathFrame = "C:\\Projects\\Output\\file1\\correctX\\img_frame_" + number + ".jpg";

					count++;
					imwrite(pathConvex, convexBlob);
					imwrite(pathConvexMask, convexBlobMask);
					imwrite(pathBox, rectBlob);
					imwrite(pathFrame, originalFrame);

					////#*cvNamedWindow("contourRegionConvex", CV_WINDOW_NORMAL);
					////#*cvNamedWindow("contourRegionBox", CV_WINDOW_NORMAL);
					////#*("contourRegionConvexMask", CV_WINDOW_NORMAL);

					////*imshow("contourRegionConvex", contourRegionConvex);
					////*imshow("contourRegionBox", contourRegionBox);
					////*imshow("contourRegionConvexMask", contourRegionConvexMask);

					//cvResizeWindow("contourRegionBox", contourRegionBox.cols, contourRegionBox.rows); 
					/*cvResizeWindow("contourRegionConvex", contourRegionConvex.rows, contourRegionConvex.cols);
					cvResizeWindow("contourRegionBox", contourRegionBox.cols, contourRegionBox.rows);*/

					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);
					
				}
				else{
					imwrite("C:\\Projects\\Output\\file1\\nonX\\" + ts + to_string(i) + ".jpg", convexBlob);


					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);
		
				}
			}

		}
	}
	return 0;
}

Mat drawHist(Mat greyImage)
{////
	float colourFrequency2[256] = {}; // u should give ={} bcos it will hav garbage values frm that array.
	for (int i = 0; i < greyImage.rows; i++){
		for (int j = 0; j < greyImage.cols; j++){
			int pixel = greyImage.at<uchar>(i, j);
			colourFrequency2[pixel] += 1;
		}
	}

	float max = 0.0;
	for (int i = 0; i < 256; i++){
		if (max < colourFrequency2[i]){
			max = colourFrequency2[i];
		}
	}
	Mat histogram2(310, 260, CV_8UC3, Scalar(255, 255, 255));

	int hist2[256] = {};
	float maxd = max;
	for (int i = 0; i < 256; i++){
		hist2[i] = cvRound(double(colourFrequency2[i] / maxd) * 300.0);
		Point pt1 = Point(i, 300 - hist2[i]);
		Point pt2 = Point(i, 300);
		line(histogram2, pt1, pt2, Scalar(0, 0, 0), 1, 8, 0);
	}

	return histogram2;

}