//
//  FeatureExtractor.cpp
//  OpencvTut
//
//  Created by Dehan on 4/15/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//

#include "FeatureExtractor.h"
#include <iostream>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"

using namespace cv;
using namespace std;
/// Global Variables
int DELAY_CAPTION = 1000;
int DELAY_BLUR = 50;
int MAX_KERNEL_LENGTH = 31;

Mat src;
Mat dst;
char window_name[] = "Filter Demo 1";

/// Function headers
int display_caption( char* caption );
int display_dst( int delay );
//global variables
Mat frame; //current frame
Mat resize_blur_Img;
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat binaryImg;
//Mat TestImg;
Mat ContourImg; //fg mask fg mask generated by MOG2 method

int mainZ(){
    VideoCapture cap(0);
    while (true) {
        Mat WebCam;
        cap.read(WebCam);
        imshow("WebCam",WebCam);
    }
    char fileName[100] = "/Users/dehan/projects/cctv.mp4"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
    VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera
    
    //morphology element
    Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3,3) );
    
    //unconditional loop
    int counter = 0;
    while (true) {
        Mat cameraFrame;
        if(!(stream1.read(frame))) //get one frame form video
            break;
        
        //Resize
        Â®
        dst = frame;
        display_dst( DELAY_CAPTION );
        counter++;
        cout << counter << "\n";
    }
    Mat originalImage = imread("/Users/dehan/projects/sharp.jpg");
    Mat originalNoisyImage = imread("/Users/dehan/projects/noisy3.png");
    Mat hsvImage(originalImage.rows,originalImage.cols,CV_8UC3,Scalar(255));
    cvtColor(originalImage, hsvImage, CV_BGR2HSV,0);
    
    Mat greyImage(originalImage.rows,originalImage.cols,CV_8UC1,Scalar(255));
    cvtColor(originalImage, greyImage, CV_BGR2GRAY,0);
    imshow("OImage: ", originalImage);
    imshow("HImage: ", hsvImage);
    imshow("GImage: ", greyImage);
    imshow("Noisy3Image: ", originalNoisyImage);

    //imshow("GreyImage: ", greyImage);
    //imshow("Filtered: ", medianFiltered);
    namedWindow( window_name, CV_WINDOW_AUTOSIZE );
    
    /// Load the source image
    src = originalNoisyImage;
    
    if( display_caption( "Original Image" ) != 0 ) { return 0; }
    
    dst = src.clone();
    if( display_dst( DELAY_CAPTION ) != 0 ) { return 0; }
    
    /// Applying Homogeneous blur
    if( display_caption( "Homogeneous Blur" ) != 0 ) { return 0; }
    
    for ( int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2 )
    { blur( src, dst, Size( i, i ), Point(-1,-1) );
        if( display_dst( DELAY_BLUR ) != 0 ) { return 0; } }
    
    /// Applying Gaussian blur
    if( display_caption( "Gaussian Blur" ) != 0 ) { return 0; }
    
    for ( int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2 )
    { GaussianBlur( src, dst, Size( i, i ), 0, 0 );
        if( display_dst( DELAY_BLUR ) != 0 ) { return 0; } }
    
    /// Applying Median blur
    if( display_caption( "Median Blur" ) != 0 ) { return 0; }
    
    for ( int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2 )
    { medianBlur ( src, dst, i );
        if( display_dst( DELAY_BLUR ) != 0 ) { return 0; } }
    
    /// Applying Bilateral Filter
    if( display_caption( "Bilateral Blur" ) != 0 ) { return 0; }
    
    for ( int i = 1; i < MAX_KERNEL_LENGTH; i = i + 2 )
    { bilateralFilter ( src, dst, i, i*2, i/2 );
        if( display_dst( DELAY_BLUR ) != 0 ) { return 0; } }
    
    cvWaitKey(0);

}

int display_caption( char* caption )
{
    dst = Mat::zeros( src.size(), src.type() );
    putText( dst, caption,
            Point( src.cols/4, src.rows/2),
            CV_FONT_HERSHEY_COMPLEX, 1, Scalar(255, 255, 255) );
    
    imshow( window_name, dst );
    int c = waitKey( DELAY_CAPTION );
    if( c >= 0 ) { return -1; }
    return 0;
}

int display_dst( int delay )
{
    imshow( window_name, dst );
    int c = waitKey ( delay );
    if( c >= 0 ) { return -1; }
    return 0;
}