//
//  ProBlobDetection.cpp
//  OpencvTut
//
//  Created by Dehan on 4/20/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//
#include <iostream>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/objdetect/objdetect.hpp"

#include <opencv2/video/background_segm.hpp>
#include <stdio.h>
using namespace cv;
using namespace std;
void getDiffInVideo();
void drawHist();
Mat src;
Mat dst;
Mat resizedFrame;
Mat processedFrame;
Mat edgeDetected;

Mat savedImage;
Mat savedHist;




//global variables
Mat frame; //current frame

int frameCounter = 0;
int main(){
    
    namedWindow("Shadow_Removed", WINDOW_AUTOSIZE);
    namedWindow("MOG2", WINDOW_AUTOSIZE);
    namedWindow("Blur_Resize", WINDOW_AUTOSIZE);
    namedWindow("Extracted Image", WINDOW_AUTOSIZE);
    namedWindow("Contour Drawing", WINDOW_AUTOSIZE);
    
    
    
    getDiffInVideo();
    
    
    char fileName[100] = "/Users/dehan/projects/loot.3gp";
    VideoCapture stream1(fileName);
    
    
    
    if(false){
        while (true) {
            int readStatus = stream1.read(frame);//get one frame form video
            if(!readStatus)
                break;
            resize(frame, frame, Size(frame.size().width/2, frame.size().height/2));
            
            GaussianBlur( frame, frame, Size(3,3), 0, 0, BORDER_DEFAULT );
            
            cvtColor(frame, processedFrame, CV_BGR2GRAY);
            
            
            imshow( "Output", frame);
            imshow( "Processed Output", processedFrame );
            
            drawHist();
            //Edge Detection
            int kernel_size = 3;
            int scale = 1;
            int delta = 0;
            int ddepth = CV_16S;
            Laplacian( frame, processedFrame, ddepth, kernel_size, scale, delta, BORDER_DEFAULT );
            convertScaleAbs( processedFrame, processedFrame );
            imshow( "Laplacian Edge Detection", processedFrame);
            waitKey(500);
            cvWaitKey(0);
            
            //Sobel Operator
            Mat grad;
            scale = 1;
            delta = 0;
            ddepth = CV_16S;
            Mat grad_x, grad_y;
            Mat abs_grad_x, abs_grad_y;
            /// Gradient X
            Sobel( frame, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );
            /// Gradient Y
            Sobel( frame, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );
            convertScaleAbs( grad_x, abs_grad_x );
            convertScaleAbs( grad_y, abs_grad_y );
            addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );
            imshow( "Sobel Edge Detection", grad);
            waitKey(500);
            cvWaitKey(0);
            
            frameCounter++;
            cout << frameCounter << "\n";
        }
    }
    waitKey(10);
    return 0;
}

void getDiffInVideo(){
    
    
    
    //global variables/Users/dehan/Documents/xc/xcode/opncvStarter/OpencvTut/OpencvTut/ProBlobDetection.cpp
    Mat frame; //current frame
    Mat resize_blur_Img;
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    Mat binaryImg;
    //Mat TestImg;
    Mat ContourImg; //fg mask fg mask generated by MOG2 method
    Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    
    pMOG2 = new BackgroundSubtractorMOG2(300,32,true);//300,0.0);
    
    char fileName[100] = "/Users/dehan/projects/cctv.mp4"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
    VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera
    
    //morphology element
    Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3,3) );
    bool flag = true;
    //unconditional loop
    while (true) {
        Mat cameraFrame;
        Mat greyFrame;
        if(!(stream1.read(frame))) //get one frame form video
            break;
        
        //cvtColor(frame, frame, CV_BGR2HSV);
        resize_blur_Img = frame;
        
        //Resize
        resize(frame, resize_blur_Img, Size(frame.size().width/2, frame.size().height/2) );
        cvtColor(resize_blur_Img, greyFrame, CV_BGR2GRAY);
        //Blur
        blur(resize_blur_Img, resize_blur_Img, Size(4,4) );
        //Background subtraction
        pMOG2->operator()(resize_blur_Img, fgMaskMOG2, -1);//,-0.5);
        
        ///////////////////////////////////////////////////////////////////
        //pre procesing
        //1 point delete
        //morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
        morphologyEx(fgMaskMOG2, binaryImg, CV_MOP_CLOSE, element);
        //morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);
        
        //Shadow delete
        //Binary
        threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);
        
        //Find contour
        ContourImg = binaryImg.clone();
        //less blob delete
        vector< vector< Point> > contours;
        findContours(ContourImg,
                     contours, // a vector of contours
                     CV_RETR_EXTERNAL, // retrieve the external contours
                     CV_CHAIN_APPROX_NONE); // all pixels of each contours
        
        vector< Rect > output;
        vector< vector< Point> >::iterator itc= contours.begin();
        
        for (int i = 0; i < contours.size(); i++)
        {
            Mat mask = Mat::zeros(greyFrame.size(), CV_8UC1);
        }
        int counter = 0;
        while (itc!=contours.end()) {
            
            Rect mr= boundingRect(Mat(*itc));
            //Mat window(mr.height,originalImage.width,CV_8UC3,Scalar(255));
            
            rectangle(resize_blur_Img, mr, CV_RGB(255,0,0));
            double heightToWidthRatio = static_cast<double>(mr.height)/ static_cast<double>(mr.width);
            if (mr.width > 30 && mr.width < 100 && heightToWidthRatio >1.3) {
                
                if (mr.height>30) {
                    
                    //                    cv::Mat color(roi.size(), CV_8UC3, cv::Scalar(0, 125, 125));
                    //                    double alpha = 0.3;
                    //                    cv::addWeighted(color, alpha, roi, 1.0 - alpha , 0.0, roi);
                    cout << "Width : " << mr.width << " Height : " << mr.height << " H/W Ratio : "<< heightToWidthRatio << endl;
                    // Get bounding box for contour
                    Rect roi = boundingRect(contours[counter]);
                    //Create bounding rect of object
                    //rect draw on origin image
                    
                    
                    
                    
                    vector<vector<Point> >hull( contours.size() );
                    convexHull( Mat(contours[counter]), hull[counter], false );

                    Mat extractedImg(greyFrame.size(), CV_8UC1);
                    //drawContours(extractedImg, contours, counter, Scalar(255), CV_FILLED);
                    drawContours( extractedImg, hull, counter, Scalar(255), CV_FILLED);
                    Mat contourRegion;
                    Mat imageROI;
                    greyFrame.copyTo(imageROI, extractedImg); // 'image' is the image you used to compute the contours.
                    contourRegion = imageROI(roi);
                    imshow("Contour Drawing", contourRegion);
                    cvMoveWindow("Contour Drawing", 400,200);
                    cvWaitKey(0);
                    
                    
                    
                    if(flag){
                        flag = false;
                        savedImage = contourRegion.clone();
                    }
                    Mat extractedHist;
                    
                    /// Set the ranges ( for B,G,R) )
                    float range[] = { 0, 256 } ;
                    const float* histRange = { range };
                    
                    bool uniform = true; bool accumulate = false;
                    /// Establish the number of bins
                    int histSize = 256;
                    calcHist( &contourRegion, 1, 0, Mat(), extractedHist, 1, &histSize, &histRange, uniform, accumulate );
                    calcHist( &savedImage, 1, 0, Mat(), savedHist, 1, &histSize, &histRange, uniform, accumulate );
                    double score = compareHist( extractedHist, savedHist, 0 );
                    printf( " Score :   %f \n", score);
                    //If correlated then mark
                    if(score > 0.7){
                        savedImage = contourRegion.clone();
                        Mat roi = resize_blur_Img(Rect(mr.x,mr.y,mr.width, mr.height));
                        Mat color(roi.size(), CV_8UC3, Scalar(0, 125, 125));
                        double alpha = 0.3;
                        addWeighted(color, alpha, roi, 1.0-alpha, 0.0, roi);
                    }
                }
            }
            
            ++itc;
        }
        
        ///////////////////////////////////////////////////////////////////
        
        //Display
        imshow("Shadow_Removed", binaryImg);
        
        imshow("MOG2", fgMaskMOG2);
        imshow("Blur_Resize", resize_blur_Img);
        
        if (waitKey(5) >= 0)
            break;
    }
}

void drawHist(){
    vector<Mat> bgr_planes;
    split( frame, bgr_planes );
    
    /// Establish the number of bins
    int histSize = 256;
    
    /// Set the ranges ( for B,G,R) )
    float range[] = { 0, 256 } ;
    const float* histRange = { range };
    
    bool uniform = true; bool accumulate = false;
    
    Mat b_hist, g_hist, r_hist;
    
    /// Compute the histograms:
    calcHist( &bgr_planes[0], 1, 0, Mat(), b_hist, 1, &histSize, &histRange, uniform, accumulate );
    calcHist( &bgr_planes[1], 1, 0, Mat(), g_hist, 1, &histSize, &histRange, uniform, accumulate );
    calcHist( &bgr_planes[2], 1, 0, Mat(), r_hist, 1, &histSize, &histRange, uniform, accumulate );
    
    // Draw the histograms for B, G and R
    int hist_w = 512; int hist_h = 400;
    int bin_w = cvRound( (double) hist_w/histSize );
    
    Mat histImage( hist_h, hist_w, CV_8UC3, Scalar( 0,0,0) );
    
    /// Normalize the result to [ 0, histImage.rows ]
    normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );
    normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );
    normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );
    
    /// Draw for each channel
    for( int i = 1; i < histSize; i++ )
    {
        
        line( histImage, Point( bin_w*(i-1), hist_h - cvRound(r_hist.at<float>(i-1)) ) ,
             Point( bin_w*(i), hist_h - cvRound(r_hist.at<float>(i)) ),
             Scalar( 255, 255, 255), 2, 8, 0  );
    }
    
    /// Display
    namedWindow("calcHist Demo", CV_WINDOW_AUTOSIZE );
    imshow("calcHist Demo", histImage );
}