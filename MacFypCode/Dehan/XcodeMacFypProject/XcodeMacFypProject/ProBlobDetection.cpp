//
//  ProBlobDetection.cpp
//  OpencvTut
//
//  Created by Dehan on 4/20/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//
#include <iostream>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/objdetect/objdetect.hpp"

#include <opencv2/video/background_segm.hpp>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
using namespace cv;
using namespace std;
void getDiffInVideo();
void drawHist();
Mat drawHist(Mat greyImage);
Mat src;
Mat dst;
Mat resizedFrame;
Mat processedFrame;
Mat edgeDetected;

Mat savedImage;
Mat savedHist;




//global variables
Mat frame; //current frame

int frameCounter = 0;
int mainProbBlob(){
    
    namedWindow("Shadow_Removed", WINDOW_AUTOSIZE);
    namedWindow("MOG2", WINDOW_AUTOSIZE);
    namedWindow("Blur_Resize", WINDOW_AUTOSIZE);
    namedWindow("Extracted Image", WINDOW_AUTOSIZE);
    namedWindow("Saved Image", WINDOW_AUTOSIZE);
    //namedWindow("Contour Drawing", WINDOW_AUTOSIZE);
    
    while (true) {
        getDiffInVideo();
    }
    
    
    
    
    char fileName[100] = "/Users/dehan/projects/loot.3gp";
    VideoCapture stream1(fileName);

    
    
    if(false){
    while (true) {
        int readStatus = stream1.read(frame);//get one frame form video
        if(!readStatus)
            break;
        resize(frame, frame, Size(frame.size().width/2, frame.size().height/2));
        
        GaussianBlur( frame, frame, Size(3,3), 0, 0, BORDER_DEFAULT );
        
        cvtColor(frame, processedFrame, CV_BGR2GRAY);
        
        
        imshow( "Output", frame);
        imshow( "Processed Output", processedFrame );
        
        drawHist();
        //Edge Detection
        int kernel_size = 3;
        int scale = 1;
        int delta = 0;
        int ddepth = CV_16S;
        Laplacian( frame, processedFrame, ddepth, kernel_size, scale, delta, BORDER_DEFAULT );
        convertScaleAbs( processedFrame, processedFrame );
        imshow( "Laplacian Edge Detection", processedFrame);
        waitKey(500);
        cvWaitKey(0);
        
        //Sobel Operator
        Mat grad;
        scale = 1;
        delta = 0;
        ddepth = CV_16S;
        Mat grad_x, grad_y;
        Mat abs_grad_x, abs_grad_y;
        /// Gradient X
        Sobel( frame, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );
        /// Gradient Y
        Sobel( frame, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );
        convertScaleAbs( grad_x, abs_grad_x );
        convertScaleAbs( grad_y, abs_grad_y );
        addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );
        imshow( "Sobel Edge Detection", grad);
        waitKey(500);
        cvWaitKey(0);
        
        frameCounter++;
        cout << frameCounter << "\n";
    }
    }
    waitKey(10);
    return 0;
}

void getDiffInVideo(){
    
    
    
    //global variables/Users/dehan/Documents/xc/xcode/opncvStarter/OpencvTut/OpencvTut/ProBlobDetection.cpp
    Mat frame; //current frame
    Mat resize_blur_Img;
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    Mat binaryImg;
    //Mat TestImg;
    Mat ContourImg; //fg mask fg mask generated by MOG2 method
    Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    
    pMOG2 = new BackgroundSubtractorMOG2(300,32,true);//300,0.0);
    
    char fileName[100] = "/Users/dehan/projects/cctv.mp4"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
    //char fileName[100] = "/Users/dehan/projects/loot.3gp";
    VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera
    
    //morphology element
    Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3,3) );
    bool flag = true;
    //unconditional loop
    
    
    float loopCounter = 1;
    float averageTime = 0;
    while (true) {
        clock_t t = clock();
        Mat cameraFrame;
        Mat greyFrame;
        if(!(stream1.read(frame))) //get one frame form video
            break;
        
        //cvtColor(frame, frame, CV_BGR2HSV);
        resize_blur_Img = frame;
        
        //Resize
        resize(frame, resize_blur_Img, Size(frame.size().width/2, frame.size().height/2) );
        cvtColor(resize_blur_Img, greyFrame, CV_BGR2GRAY);
        //Blur
        blur(resize_blur_Img, resize_blur_Img, Size(4,4) );
        //Background subtraction
        pMOG2->operator()(resize_blur_Img, fgMaskMOG2, -1);//,-0.5);
        
        ///////////////////////////////////////////////////////////////////
        //pre procesing
        //1 point delete
        //morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
        morphologyEx(fgMaskMOG2, binaryImg, CV_MOP_CLOSE, element);
        //morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);
        
        //Shadow delete
        //Binary
        threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);
        
        //Find contour
        ContourImg = binaryImg.clone();
        //less blob delete
        vector< vector< Point> > contours;
        findContours(ContourImg,
                     contours, // a vector of contours
                     CV_RETR_EXTERNAL, // retrieve the external contours
                     CV_CHAIN_APPROX_NONE); // all pixels of each contours
        
        vector< Rect > output;
        vector< vector< Point> >::iterator itc= contours.begin();
        
        for (int i = 1000000; i < contours.size(); i++)
        {
            // Get bounding box for contour
            Rect roi = boundingRect(contours[i]);
            //Create bounding rect of object
            //rect draw on origin image
            Mat mask = Mat::zeros(greyFrame.size(), CV_8UC1);
            drawContours(mask, contours, i, Scalar(255), CV_FILLED);
            Mat contourRegion;
            Mat imageROI;
            greyFrame.copyTo(imageROI, mask); // 'image' is the image you used to compute the contours.
            contourRegion = imageROI(roi);
            //imshow("Contour Drawing", contourRegion);
            //cvMoveWindow("Contour Drawing", 400,200);
            waitKey(10);
        }
        
        while (itc!=contours.end()) {
            
           
            Rect mr= boundingRect(Mat(*itc));
            //Mat window(mr.height,originalImage.width,CV_8UC3,Scalar(255));
            
            rectangle(resize_blur_Img, mr, CV_RGB(255,0,0));
            double heightToWidthRatio = static_cast<double>(mr.height)/ static_cast<double>(mr.width);
            if (mr.width > 30 && mr.width < 100 && heightToWidthRatio >1.3) {
                
                if (mr.height>30) {

//                    cv::Mat color(roi.size(), CV_8UC3, cv::Scalar(0, 125, 125));
//                    double alpha = 0.3;
//                    cv::addWeighted(color, alpha, roi, 1.0 - alpha , 0.0, roi);
                    //cout << "Width : " << mr.width << " Height : " << mr.height << " H/W Ratio : "<< heightToWidthRatio << endl;
                    Mat extractedImg(mr.height, mr.width, CV_8UC1);
                    
                    for (int row=0; row < mr.height; row++) {
                        for (int col=0; col < mr.width; col++) {
                            extractedImg.at<uchar>(row,col) =greyFrame.at<uchar>(row + mr.y,col+mr.x);
                            
                        }
                    }

                    if(flag){
                        flag = false;
                        savedImage = extractedImg.clone();
                        
                        imshow("Saved Image", savedImage);
                        resizeWindow("Saved Image", 200, 200);
                        cvMoveWindow("Saved Image", 10,457);
                    }
                    imshow("Extracted Image", extractedImg);
                    cvMoveWindow("Extracted Image", 472,457);
                    resizeWindow("Extracted Imagex", 200, 200);
                    
                    Mat extractedHist;
                    
                    /// Set the ranges ( for B,G,R) )
                    float range[] = { 0, 256 } ;
                    const float* histRange = { range };
                    
                    bool uniform = true;
                    bool accumulate = false;
                    /// Establish the number of bins
                    int histSize = 256;
                    calcHist( &extractedImg, 1, 0, Mat(), extractedHist, 1, &histSize, &histRange, uniform, accumulate );
                    calcHist( &savedImage, 1, 0, Mat(), savedHist, 1, &histSize, &histRange, uniform, accumulate );
                    double score = compareHist( extractedHist, savedHist, 0 );
                    //printf( " Score :   %f \n", score);
                    //If correlated then mark
                    if(score > 0.7){
                        Mat histogramSaved = drawHist(savedImage);
                        Mat histogramExtracted = drawHist(extractedImg);
                        imshow("Extracted Histo", histogramExtracted);
                        cvMoveWindow("Extracted Histo", 661,457);
                        imshow("Saved Histo", histogramSaved);
                        cvMoveWindow("Saved Histo", 211,457);
                        
                        
                        //cvWaitKey(0);
                        savedImage = extractedImg.clone();
                        imshow("Saved Image", savedImage);
                        resizeWindow("Saved Image", 200, 200);
                        cvMoveWindow("Saved Image", 10,457);

                        
                        Mat roi = resize_blur_Img(Rect(mr.x,mr.y,mr.width, mr.height));
                        Mat color(roi.size(), CV_8UC3, Scalar(0, 125, 125));
                        double alpha = 0.3;
                        addWeighted(color, alpha, roi, 1.0-alpha, 0.0, roi);
                        
                    }
                }
            }

            ++itc;
        }
        
        ///////////////////////////////////////////////////////////////////
        
        //Display
        //imshow("Shadow_Removed", binaryImg);]
        imshow("Blur_Resize", resize_blur_Img);
        cvMoveWindow("Blur_Resize", 0,0);
        imshow("MOG2", fgMaskMOG2);
        cvMoveWindow("MOG2", 641,0);
        t = clock() -t;
        averageTime = (averageTime * (loopCounter-1) + ((float)t/CLOCKS_PER_SEC)*1000)/(float)loopCounter;
        printf("\nElapsed Time is         : %f ms \n", ((float)t/CLOCKS_PER_SEC)*1000);
        printf("Average Elapsed Time is  : %f ms \n", averageTime);
        loopCounter++;
        
        if (waitKey(500) >= 0)
            break;
    }
    
    
    
}

Mat drawHist(Mat greyImage){
    float colourFrequency2[256] = {}; // u should give ={} bcos it will hav garbage values frm that array.
    for (int i = 0; i < greyImage.rows; i++){
        for (int j = 0; j < greyImage.cols; j++){
            int pixel = greyImage.at<uchar>(i, j);
            colourFrequency2[pixel] += 1;
        }
    }
    
    float max = 0.0;
    for (int i = 0; i < 256; i++){
        if (max < colourFrequency2[i]){
            max = colourFrequency2[i];
        }
    }
    Mat histogram2(310, 260, CV_8UC3, Scalar(255, 255, 255));
    
    int hist2[256] = {};
    float maxd = max;
    for (int i = 0; i < 256; i++){
        hist2[i] = cvRound(double(colourFrequency2[i] / maxd) * 300.0);
        Point pt1 = Point(i, 300-hist2[i]);
        Point pt2 = Point(i, 300);
        line(histogram2, pt1, pt2, Scalar(0, 0, 0), 1, 8, 0);
    }
    
    return histogram2;
}